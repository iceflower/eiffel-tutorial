# 클래스

> **2025년 업데이트** - EiffelStudio 25.02 기준

에펠은 **순수 객체지향 언어**입니다. 모든 코드는 클래스 안에 존재합니다.

---

## 클래스 기본 구조

```eiffel
note
    description: "클래스 설명"
    author: "작성자"

class
    CLASS_NAME

inherit
    PARENT_CLASS  -- 상속 (선택)

create
    make  -- 생성자 지정

feature {NONE} -- Initialization

    make
        do
            -- 초기화 코드
        end

feature -- Access

    attribute1: TYPE
    attribute2: TYPE

feature -- Query

    some_query: RESULT_TYPE
        do
            Result := ...
        end

feature -- Command

    some_command
        do
            -- 상태 변경 코드
        end

invariant
    -- 클래스 불변식

end
```

---

## Feature 분류

에펠에서는 클래스 멤버를 **feature**라고 합니다.

### Attribute (속성)

```eiffel
feature -- Attributes

    name: STRING
        -- 사람의 이름

    age: INTEGER
        -- 나이

    is_active: BOOLEAN
        -- 활성화 여부
```

### Query (질의)

상태를 **변경하지 않고** 값을 반환합니다.

```eiffel
feature -- Query

    full_name: STRING
            -- 전체 이름 반환
        do
            Result := first_name + " " + last_name
        end

    is_adult: BOOLEAN
            -- 성인인가?
        do
            Result := age >= 18
        end
```

**중요**: `Result`는 반환값을 위한 예약어입니다. `return`이 없습니다!

### Command (명령)

상태를 **변경**합니다. 반환값이 없습니다.

```eiffel
feature -- Command

    set_name (new_name: STRING)
            -- 이름 변경
        do
            name := new_name
        end

    increment_age
            -- 나이 1 증가
        do
            age := age + 1
        end
```

### Command-Query Separation

에펠의 핵심 원칙 중 하나입니다:

> **Query**는 상태를 변경하면 안 되고, **Command**는 값을 반환하면 안 된다.

```eiffel
-- 나쁜 예 (다른 언어)
function pop(): Item {
    item = stack.top()   -- 읽기
    stack.remove_top()   -- 변경
    return item          -- 반환
}

-- 좋은 예 (Eiffel)
feature -- Query
    top: ITEM
        do Result := items.last end

feature -- Command
    pop
        do items.finish; items.remove end
```

---

## 생성자 (Creation Procedure)

### 기본 생성자

```eiffel
class
    PERSON

create
    make

feature {NONE} -- Initialization

    make (a_name: STRING)
        do
            name := a_name
            age := 0
        end

feature -- Access
    name: STRING
    age: INTEGER
end
```

### 여러 생성자

```eiffel
create
    make,
    make_with_age,
    make_default

feature {NONE} -- Initialization

    make (a_name: STRING)
        do
            name := a_name
            age := 0
        end

    make_with_age (a_name: STRING; a_age: INTEGER)
        do
            name := a_name
            age := a_age
        end

    make_default
        do
            name := "Unknown"
            age := 0
        end
```

### 객체 생성

```eiffel
local
    p1, p2, p3: PERSON
do
    create p1.make ("Alice")
    create p2.make_with_age ("Bob", 25)
    create p3.make_default
end
```

---

## 접근 제어

`feature` 뒤에 클라이언트를 지정하여 접근을 제어합니다.

```eiffel
feature {NONE}  -- private: 현재 클래스만 접근
    internal_data: INTEGER

feature {CLASS_A, CLASS_B}  -- 특정 클래스만 접근
    semi_private_data: STRING

feature  -- public: 모두 접근 가능
    public_data: STRING

feature {CURRENT}  -- 현재 객체만 접근 (같은 클래스의 다른 인스턴스도 불가)
    very_private: INTEGER
```

### 접근 제어 요약

| 선언 | 접근 범위 |
|------|----------|
| `feature` | 모든 클래스 (public) |
| `feature {NONE}` | 현재 클래스만 (private) |
| `feature {A, B}` | A, B 클래스만 |
| `feature {ANY}` | 모든 클래스 (public과 동일) |

---

## Current와 Result

### Current

현재 객체를 참조합니다 (다른 언어의 `this`, `self`).

```eiffel
compare_with (other: PERSON): BOOLEAN
    do
        Result := Current.age > other.age
    end

clone_self: PERSON
    do
        create Result.make_with_age (name, age)
    end
```

### Result

함수의 반환값을 저장합니다.

```eiffel
calculate_sum (a, b: INTEGER): INTEGER
    do
        Result := a + b
        -- Result := Result * 2  -- 여러 번 할당 가능
    end
```

---

## 완전한 예제

```eiffel
note
    description: "은행 계좌 클래스"

class
    BANK_ACCOUNT

create
    make

feature {NONE} -- Initialization

    make (owner_name: STRING; initial_balance: INTEGER)
        require
            valid_name: not owner_name.is_empty
            non_negative: initial_balance >= 0
        do
            owner := owner_name
            balance := initial_balance
        ensure
            owner_set: owner = owner_name
            balance_set: balance = initial_balance
        end

feature -- Access

    owner: STRING
        -- 계좌 소유자

    balance: INTEGER
        -- 현재 잔액

feature -- Query

    can_withdraw (amount: INTEGER): BOOLEAN
            -- 출금 가능 여부
        do
            Result := amount > 0 and amount <= balance
        end

feature -- Command

    deposit (amount: INTEGER)
            -- 입금
        require
            positive: amount > 0
        do
            balance := balance + amount
        ensure
            increased: balance = old balance + amount
        end

    withdraw (amount: INTEGER)
            -- 출금
        require
            positive: amount > 0
            sufficient: amount <= balance
        do
            balance := balance - amount
        ensure
            decreased: balance = old balance - amount
        end

invariant
    non_negative_balance: balance >= 0
    owner_exists: owner /= Void

end
```

---

## 객체 비교

### 참조 비교 vs 값 비교

```eiffel
local
    s1, s2: STRING
do
    s1 := "hello"
    s2 := "hello"

    -- 참조 비교 (동일한 객체?)
    if s1 = s2 then
        print ("같은 객체%N")
    end

    -- 값 비교 (내용이 같음?)
    if s1.is_equal (s2) then
        print ("같은 값%N")
    end

    -- ~ 연산자 (is_equal 단축)
    if s1 ~ s2 then
        print ("같은 값%N")
    end
end
```

| 연산 | 의미 |
|------|------|
| `a = b` | 참조 비교 (동일한 객체?) |
| `a ~ b` | 값 비교 (is_equal) |
| `a /= b` | 참조가 다름 |
| `not (a ~ b)` | 값이 다름 |

---

## 연습 문제

1. `RECTANGLE` 클래스를 만들어 넓이와 둘레를 계산하세요.
2. `STUDENT` 클래스를 만들어 성적 평균을 계산하세요.
3. `COUNTER` 클래스를 만들어 증가, 감소, 초기화 기능을 구현하세요.

---

## 에이전트 (Agent) 맛보기

에이전트는 함수나 프로시저를 객체로 캡슐화합니다 (다른 언어의 람다, 클로저).

```eiffel
local
    my_agent: PROCEDURE [TUPLE [INTEGER]]
    numbers: ARRAYED_LIST [INTEGER]
do
    -- 프로시저를 에이전트로 캡슐화
    my_agent := agent print_number

    -- 호출
    my_agent.call ([42])

    -- 컬렉션에 적용
    create numbers.make_from_array (<<1, 2, 3, 4, 5>>)
    numbers.do_all (agent print_number)
end

print_number (n: INTEGER)
    do
        print (n.out + " ")
    end
```

### 인라인 에이전트 (람다)

```eiffel
local
    double: FUNCTION [TUPLE [INTEGER], INTEGER]
    numbers: ARRAYED_LIST [INTEGER]
do
    -- 인라인 에이전트 (람다 표현식)
    double := agent (x: INTEGER): INTEGER do Result := x * 2 end

    print (double.item ([5]))  -- 10

    -- 리스트에서 사용
    create numbers.make_from_array (<<1, 2, 3>>)
    across numbers as c loop
        print (double.item ([c.item]).out + " ")  -- 2 4 6
    end
end
```

---

## 참고 자료

- [Eiffel 클래스 구조](https://www.eiffel.org/doc/eiffel/Class_structure)
- [Command-Query Separation](https://martinfowler.com/bliki/CommandQuerySeparation.html)
- [Agents](https://www.eiffel.org/doc/eiffel/Agents)

---

## 다음 단계

[05_상속.md](../05_inheritance/05_상속.md)에서 클래스 상속과 다형성을 학습합니다.
