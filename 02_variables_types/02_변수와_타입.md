# 변수와 타입

> **2025년 업데이트** - EiffelStudio 25.02 기준

에펠은 **정적 타입 언어**입니다. 모든 변수는 선언 시 타입을 명시해야 합니다.

---

## 기본 타입 (Expanded Classes)

에펠의 기본 타입은 모두 **expanded class**입니다. 값으로 저장되며 힙 할당이 필요 없습니다.

### 숫자 타입

| 타입 | 설명 | 범위 |
|------|------|------|
| `INTEGER` | 32비트 정수 | -2,147,483,648 ~ 2,147,483,647 |
| `INTEGER_8` | 8비트 정수 | -128 ~ 127 |
| `INTEGER_16` | 16비트 정수 | -32,768 ~ 32,767 |
| `INTEGER_64` | 64비트 정수 | ±9.2 × 10^18 |
| `NATURAL` | 부호 없는 32비트 | 0 ~ 4,294,967,295 |
| `NATURAL_8` | 부호 없는 8비트 | 0 ~ 255 |
| `NATURAL_16` | 부호 없는 16비트 | 0 ~ 65,535 |
| `NATURAL_64` | 부호 없는 64비트 | 0 ~ 1.8 × 10^19 |
| `REAL_32` | 32비트 실수 | 단정밀도 (약 7자리) |
| `REAL_64` | 64비트 실수 | 배정밀도 (약 15자리) |

### 기타 기본 타입

| 타입 | 설명 | 예시 |
|------|------|------|
| `BOOLEAN` | 참/거짓 | `True`, `False` |
| `CHARACTER` | 8비트 문자 | `'A'`, `'가'` |
| `CHARACTER_32` | 32비트 유니코드 | 모든 유니코드 문자 |
| `POINTER` | 메모리 주소 | 외부 C 라이브러리 연동용 |

### 참조 타입

| 타입 | 설명 | 특징 |
|------|------|------|
| `STRING` | 가변 문자열 | 내용 수정 가능 |
| `STRING_32` | 32비트 유니코드 문자열 | 다국어 지원 |
| `IMMUTABLE_STRING_32` | 불변 문자열 | 스레드 안전, 성능 최적화 |

---

## 변수 선언

### 클래스 속성 (Attribute)

```eiffel
class
    EXAMPLE

feature -- Attributes

    name: STRING
        -- 클래스 수준 변수 (인스턴스 변수)

    count: INTEGER
        -- 정수 속성

    price: REAL_64
        -- 실수 속성 (기본값: 0.0)

    is_active: BOOLEAN
        -- 불리언 속성 (기본값: False)

end
```

### 지역 변수 (Local)

```eiffel
feature -- Methods

    calculate
        local
            temp: INTEGER           -- 지역 변수
            result_str: STRING      -- 지역 변수
            values: ARRAY [INTEGER] -- 배열 지역 변수
        do
            temp := 100
            result_str := "계산 완료"
            create values.make_filled (0, 1, 10)
        end
```

**중요**: 지역 변수는 반드시 `local` 블록에 선언해야 합니다. `do` 안에서는 선언 불가!

### 기본값

| 타입 | 기본값 |
|------|--------|
| `INTEGER`, `NATURAL` | `0` |
| `REAL_32`, `REAL_64` | `0.0` |
| `BOOLEAN` | `False` |
| `CHARACTER` | `%U` (null 문자) |
| 참조 타입 | `Void` |

---

## 할당 연산자

에펠에서 할당은 **`:=`**를 사용합니다.

```eiffel
-- 올바른 할당
name := "Eiffel"
count := 42
price := 99.99
is_active := True

-- 잘못된 할당 (컴파일 오류!)
name = "Eiffel"  -- = 는 비교 연산자!
```

### 연산자 비교

| 연산자 | 용도 | 예시 |
|--------|------|------|
| `:=` | 할당 | `x := 10` |
| `=` | 참조/값 동등 비교 | `if x = 10 then` |
| `/=` | 불일치 비교 | `if x /= 10 then` |
| `~` | 객체 동등 비교 (is_equal) | `if s1 ~ s2 then` |
| `/~` | 객체 불일치 비교 | `if s1 /~ s2 then` |

---

## 타입 변환

### 숫자 변환

```eiffel
local
    int_val: INTEGER
    int64_val: INTEGER_64
    real_val: REAL_64
    str_val: STRING
    nat_val: NATURAL
do
    int_val := 42

    -- INTEGER -> REAL
    real_val := int_val.to_double
    -- 결과: 42.0

    -- INTEGER -> INTEGER_64
    int64_val := int_val.to_integer_64

    -- INTEGER -> STRING
    str_val := int_val.out
    -- 결과: "42"

    -- REAL -> INTEGER
    real_val := 3.7
    int_val := real_val.truncated_to_integer  -- 버림: 3
    int_val := real_val.rounded                -- 반올림: 4
    int_val := real_val.floor.as_integer_32   -- 내림: 3
    int_val := real_val.ceiling.as_integer_32 -- 올림: 4

    -- INTEGER -> NATURAL (양수일 때만)
    if int_val >= 0 then
        nat_val := int_val.to_natural_32
    end
end
```

### 문자열 변환

```eiffel
local
    s: STRING
    n: INTEGER
    r: REAL_64
do
    -- STRING -> INTEGER
    s := "123"
    if s.is_integer then
        n := s.to_integer
    end

    -- STRING -> REAL
    s := "3.14"
    if s.is_real then
        r := s.to_real_64
    end

    -- 모든 타입 -> STRING
    s := n.out           -- INTEGER -> STRING
    s := r.out           -- REAL -> STRING
    s := True.out        -- BOOLEAN -> STRING ("True")
end
```

---

## 문자열 조작

### 기본 연산

```eiffel
local
    s1, s2, result: STRING
do
    s1 := "Hello"
    s2 := "World"

    -- 문자열 연결
    result := s1 + ", " + s2 + "!"
    -- 결과: "Hello, World!"

    -- 길이
    print (result.count)  -- 13

    -- 특정 위치 문자 (1부터 시작!)
    print (result.item (1))  -- 'H'
    print (result [7])       -- ',' ([] 연산자)

    -- 대소문자 변환 (원본 유지, 새 문자열 반환)
    print (result.as_upper)  -- "HELLO, WORLD!"
    print (result.as_lower)  -- "hello, world!"

    -- 원본 수정
    result.to_upper  -- result 자체가 대문자로 변경
end
```

### 문자열 검색

```eiffel
local
    s: STRING
    pos: INTEGER
do
    s := "Hello, World!"

    -- 부분 문자열 포함 여부
    if s.has_substring ("World") then
        print ("포함됨%N")
    end

    -- 시작/끝 확인
    if s.starts_with ("Hello") then
        print ("Hello로 시작%N")
    end

    if s.ends_with ("!") then
        print ("!로 끝남%N")
    end

    -- 부분 문자열 위치 찾기 (1부터 시작)
    pos := s.substring_index ("World", 1)  -- 8

    -- 문자 찾기
    if s.has ('o') then
        pos := s.index_of ('o', 1)  -- 5 (첫 번째 'o')
    end
end
```

### 부분 문자열 추출

```eiffel
local
    s, sub: STRING
do
    s := "Hello, World!"

    -- substring (시작, 끝) - 1부터 시작, 끝 포함
    sub := s.substring (1, 5)   -- "Hello"
    sub := s.substring (8, 12)  -- "World"

    -- 앞/뒤 제거
    sub := s.substring (1, s.count - 1)  -- "Hello, World"

    -- 문자열 분할 (split)
    -- across s.split (',') as part loop
    --     print (part.item + "%N")
    -- end
end
```

### 문자열 수정

```eiffel
local
    s: STRING
do
    s := "Hello"

    -- 추가
    s.append (", World!")     -- "Hello, World!"
    s.prepend ("Say: ")       -- "Say: Hello, World!"

    -- 삽입
    s.insert_string ("***", 5)  -- 5번 위치에 삽입

    -- 삭제
    s.remove_head (4)          -- 앞 4글자 삭제
    s.remove_tail (1)          -- 뒤 1글자 삭제

    -- 교체
    s.replace_substring_all ("old", "new")

    -- 공백 제거
    s.left_adjust   -- 왼쪽 공백 제거
    s.right_adjust  -- 오른쪽 공백 제거
    s.adjust        -- 양쪽 공백 제거
end
```

---

## 특수 문자

에펠에서 특수 문자는 `%` 접두사를 사용합니다.

| 표현 | 의미 |
|------|------|
| `%N` | 줄바꿈 (newline) |
| `%T` | 탭 |
| `%R` | 캐리지 리턴 |
| `%"` | 쌍따옴표 |
| `%'` | 작은따옴표 |
| `%%` | 퍼센트 기호 |
| `%/65/` | 아스키 코드 65 ('A') |
| `%U` | null 문자 |

```eiffel
print ("첫째 줄%N둘째 줄%N")
print ("탭으로%T구분%N")
print ("그가 말했다: %"안녕하세요%"%N")
```

---

## Verbatim 문자열 (여러 줄)

긴 문자열은 `"[` ... `]"` 구문을 사용합니다.

```eiffel
local
    html: STRING
    json: STRING
do
    html := "[
<!DOCTYPE html>
<html>
<head>
    <title>에펠</title>
</head>
<body>
    <h1>Hello, Eiffel!</h1>
</body>
</html>
    ]"

    json := "[
{
    "name": "Eiffel",
    "version": 25.02,
    "features": ["DbC", "Multiple Inheritance", "Void Safety"]
}
    ]"
end
```

---

## Void 안전성 (Attached Types)

에펠의 핵심 기능 중 하나입니다. null 참조 오류를 컴파일 타임에 방지합니다.

### attached vs detachable

```eiffel
feature -- Attributes

    required_name: STRING
        -- attached (기본값): 절대 Void가 될 수 없음

    optional_name: detachable STRING
        -- detachable: Void일 수 있음
```

### Void 체크

```eiffel
feature -- Methods

    display_name
        do
            -- 방법 1: 직접 비교
            if optional_name /= Void then
                print (optional_name)  -- 여전히 컴파일러 경고 가능
            end

            -- 방법 2: attached ... as 구문 (권장!)
            if attached optional_name as name then
                -- 이 블록 안에서 name은 attached STRING
                print (name)
                print (name.count)  -- 안전하게 호출 가능
            else
                print ("이름 없음")
            end

            -- 방법 3: check 문
            check attached optional_name as name then
                print (name)
            end
        end
```

### Object Test (타입 테스트)

```eiffel
local
    obj: ANY
    s: STRING
do
    obj := "Hello"

    -- 타입 테스트 + 캐스팅
    if attached {STRING} obj as str then
        -- str은 STRING 타입으로 사용 가능
        print (str.as_upper)
    end
end
```

---

## 튜플 (TUPLE)

여러 값을 하나로 묶는 간편한 방법입니다.

```eiffel
local
    -- 이름 있는 튜플
    person: TUPLE [name: STRING; age: INTEGER; active: BOOLEAN]

    -- 이름 없는 튜플
    point: TUPLE [REAL_64, REAL_64]

    -- 함수 반환용
    result: TUPLE [success: BOOLEAN; message: STRING; code: INTEGER]
do
    -- 생성
    person := ["홍길동", 30, True]
    point := [10.5, 20.3]
    result := [True, "성공", 200]

    -- 접근 (이름으로)
    print (person.name)    -- "홍길동"
    print (person.age)     -- 30

    -- 접근 (인덱스로)
    print (point [1])      -- 10.5
    print (point [2])      -- 20.3

    -- 조건부 사용
    if result.success then
        print (result.message + " (" + result.code.out + ")%N")
    end
end
```

---

## 상수 정의

```eiffel
feature -- Constants

    Pi: REAL_64 = 3.14159265358979
        -- 원주율 상수

    Max_size: INTEGER = 100
        -- 최대 크기

    App_name: STRING = "My Application"
        -- 애플리케이션 이름

    Version: NATURAL = 2
        -- 버전 번호

    Debug_mode: BOOLEAN = True
        -- 디버그 모드 플래그
```

---

## Once 기능 (싱글톤 패턴)

```eiffel
feature -- Once functions (한 번만 실행)

    shared_instance: MY_CLASS
            -- 싱글톤 인스턴스
        once
            create Result.make
        end

    configuration: HASH_TABLE [STRING, STRING]
            -- 설정값 (한 번만 로드)
        once
            create Result.make (10)
            Result.put ("localhost", "host")
            Result.put ("8080", "port")
        end

    pi_value: REAL_64
            -- 계산된 상수
        once
            Result := 3.14159265358979
        end
```

---

## 연습 문제

1. 두 정수를 입력받아 합, 차, 곱, 몫을 계산하는 프로그램을 작성하세요.
2. 문자열을 뒤집는 기능을 구현하세요.
3. 섭씨 온도를 화씨로 변환하는 프로그램을 작성하세요. (F = C × 9/5 + 32)
4. `detachable STRING`을 받아 안전하게 출력하는 함수를 작성하세요.

---

## 참고 자료

- [Eiffel 타입 시스템](https://www.eiffel.org/doc/eiffel/Eiffel_types)
- [Void Safety](https://www.eiffel.org/doc/eiffel/Void-safe_programming_in_Eiffel)
- [STRING 클래스](https://www.eiffel.org/files/doc/static/24.05/libraries/base/string_8_chart.html)

---

## 다음 단계

[03_조건문과_반복문.md](../03_conditionals_loops/03_조건문과_반복문.md)에서 제어 구조를 학습합니다.
