# 조건문과 반복문

> **2025년 업데이트** - EiffelStudio 25.02 기준

에펠의 제어 구조는 다른 언어와 비슷하지만, 몇 가지 독특한 특징이 있습니다.

---

## 조건문

### if-then-else

```eiffel
if condition then
    -- condition이 True일 때 실행
elseif other_condition then
    -- other_condition이 True일 때 실행
else
    -- 모든 조건이 False일 때 실행
end
```

#### 예제: 학점 계산

```eiffel
local
    score: INTEGER
    grade: STRING
do
    score := 85

    if score >= 90 then
        grade := "A"
    elseif score >= 80 then
        grade := "B"
    elseif score >= 70 then
        grade := "C"
    elseif score >= 60 then
        grade := "D"
    else
        grade := "F"
    end

    print ("점수: " + score.out + " -> 학점: " + grade + "%N")
end
```

---

## 논리 연산자

| 연산자 | 의미 | 예시 |
|--------|------|------|
| `and` | 논리 AND | `a and b` |
| `or` | 논리 OR | `a or b` |
| `not` | 논리 NOT | `not a` |
| `xor` | 배타적 OR | `a xor b` |
| `implies` | 함축 (A → B) | `a implies b` |
| `and then` | 단락 평가 AND | `a and then b` |
| `or else` | 단락 평가 OR | `a or else b` |

### 단락 평가 (Short-circuit Evaluation)

```eiffel
-- and then: 첫 번째가 False면 두 번째 평가 안 함
if list /= Void and then list.count > 0 then
    -- list가 Void가 아닐 때만 count 확인
end

-- or else: 첫 번째가 True면 두 번째 평가 안 함
if is_valid or else try_validate then
    -- is_valid가 True면 try_validate 호출 안 함
end
```

### implies 연산자

`A implies B`는 `not A or else B`와 동일합니다.

```eiffel
-- "비가 오면 우산을 쓴다"
-- 비가 안 오면 우산 여부 상관없음
if is_raining implies has_umbrella then
    print ("괜찮습니다%N")
end
```

| A | B | A implies B |
|---|---|-------------|
| True | True | True |
| True | False | False |
| False | True | True |
| False | False | True |

---

## inspect (Switch/Case)

`inspect`는 다른 언어의 `switch`문과 유사합니다.

```eiffel
local
    day: INTEGER
    day_name: STRING
do
    day := 3

    inspect day
    when 1 then
        day_name := "월요일"
    when 2 then
        day_name := "화요일"
    when 3 then
        day_name := "수요일"
    when 4 then
        day_name := "목요일"
    when 5 then
        day_name := "금요일"
    when 6, 7 then
        -- 여러 값을 하나로 처리
        day_name := "주말"
    else
        day_name := "잘못된 값"
    end
end
```

### 범위 사용

```eiffel
inspect score
when 90..100 then
    grade := "A"
when 80..89 then
    grade := "B"
when 70..79 then
    grade := "C"
else
    grade := "F"
end
```

---

## 반복문

### from-until-loop

에펠의 기본 반복문입니다. **중요**: `until` 조건이 **True가 되면 종료**합니다 (while과 반대!).

```eiffel
from
    -- 초기화
    i := 1
until
    -- 종료 조건: True가 되면 종료
    i > 10
loop
    -- 반복 본문
    print (i.out + " ")
    i := i + 1
end
```

#### 구조 비교

| 언어 | 구조 | 조건 의미 |
|------|------|----------|
| C/Java | `while (i <= 10)` | True인 동안 계속 |
| Python | `while i <= 10:` | True인 동안 계속 |
| **Eiffel** | `until i > 10` | **True가 되면 종료** |

#### 예제: 1부터 100까지 합

```eiffel
local
    i, sum: INTEGER
do
    from
        i := 1
        sum := 0
    until
        i > 100
    loop
        sum := sum + i
        i := i + 1
    end

    print ("1부터 100까지 합: " + sum.out + "%N")
    -- 결과: 5050
end
```

#### 예제: 팩토리얼

```eiffel
local
    n, i, factorial: INTEGER
do
    n := 5

    from
        i := 1
        factorial := 1
    until
        i > n
    loop
        factorial := factorial * i
        i := i + 1
    end

    print (n.out + "! = " + factorial.out + "%N")
    -- 결과: 5! = 120
end
```

---

## 루프 불변식과 변형식

에펠 루프는 Design by Contract를 지원합니다.

```eiffel
from
    i := 1
    sum := 0
invariant
    -- 루프 불변식: 매 반복마다 참이어야 함
    sum >= 0
    i >= 1
variant
    -- 변형식: 매 반복마다 감소해야 함 (종료 보장)
    n - i + 1
until
    i > n
loop
    sum := sum + i
    i := i + 1
end
```

| 절 | 목적 |
|-----|------|
| `invariant` | 루프의 정확성 보장 (매 반복 검사) |
| `variant` | 루프 종료 보장 (음수가 되면 안 됨) |

---

## across 반복문 (컬렉션 순회)

`across`는 컬렉션을 순회할 때 사용합니다.

### 배열 순회

```eiffel
local
    numbers: ARRAY [INTEGER]
do
    create numbers.make_filled (0, 1, 5)
    numbers [1] := 10
    numbers [2] := 20
    numbers [3] := 30
    numbers [4] := 40
    numbers [5] := 50

    across numbers as cursor loop
        print (cursor.item.out + " ")
    end
    -- 출력: 10 20 30 40 50
end
```

### 리스트 순회

```eiffel
local
    names: ARRAYED_LIST [STRING]
do
    create names.make (3)
    names.extend ("Alice")
    names.extend ("Bob")
    names.extend ("Charlie")

    across names as cursor loop
        print (cursor.item + "%N")
    end
end
```

### 인덱스 사용

```eiffel
across names as cursor loop
    print (cursor.cursor_index.out + ": " + cursor.item + "%N")
end
-- 출력:
-- 1: Alice
-- 2: Bob
-- 3: Charlie
```

### all/some 표현식

```eiffel
local
    numbers: ARRAY [INTEGER]
    all_positive: BOOLEAN
    has_zero: BOOLEAN
do
    -- 모든 원소가 조건 만족?
    all_positive := across numbers as c all c.item > 0 end

    -- 하나라도 조건 만족?
    has_zero := across numbers as c some c.item = 0 end
end
```

---

## 반복문 비교

```eiffel
-- 1. from-until (인덱스 기반)
from i := 1 until i > 10 loop
    print (i)
    i := i + 1
end

-- 2. across (컬렉션 기반)
across my_list as cursor loop
    print (cursor.item)
end
```

| 상황 | 권장 구문 |
|------|----------|
| 인덱스가 필요한 경우 | `from-until` |
| 컬렉션 순회 | `across` |
| 복잡한 종료 조건 | `from-until` |
| 간단한 순회 | `across` |

---

## 연습 문제

1. 1부터 N까지 홀수의 합을 구하는 프로그램을 작성하세요.
2. 피보나치 수열의 처음 20개 항을 출력하세요.
3. 배열에서 최대값과 최소값을 찾는 프로그램을 작성하세요.

---

## 매니페스트 배열 (Manifest Array)

EiffelStudio에서 배열을 간단히 생성하는 문법입니다.

```eiffel
local
    numbers: ARRAY [INTEGER]
    names: ARRAY [STRING]
    mixed: ARRAY [ANY]
do
    -- << >> 구문으로 배열 생성
    numbers := <<1, 2, 3, 4, 5>>
    names := <<"Alice", "Bob", "Charlie">>

    -- across로 순회
    across numbers as cursor loop
        print (cursor.item.out + " ")
    end
end
```

---

## 예외 처리 (Rescue)

```eiffel
feature

    risky_operation
        local
            retried: BOOLEAN
        do
            if not retried then
                -- 위험한 작업
                do_something_risky
            else
                -- 재시도 시 안전한 대안
                do_safe_alternative
            end
        rescue
            -- 예외 발생 시 실행
            retried := True
            retry  -- do 블록 재실행
        end
```

---

## 참고 자료

- [Eiffel 제어 구조](https://www.eiffel.org/doc/eiffel/Control_structures)
- [Loop Invariants](https://www.eiffel.org/doc/eiffel/Loop_invariants)

---

## 다음 단계

[04_클래스.md](../04_classes/04_클래스.md)에서 클래스 정의와 객체지향 프로그래밍을 학습합니다.
